# Syllabus Breakdown for OOP Semester Examination

## Module 1: Introduction to C++

- [ ] Object Oriented Technology
- [ ] Definition and Principles
- [ ] Comparison with Procedural Programming

### Advantages of OOP
- [ ] Encapsulation
- [ ] Inheritance
- [ ] Polymorphism
- [ ] Reusability

### Input Output in C++
- [ ] Basic input/output operations
- [ ] Stream objects (cin, cout)
- [ ] Formatting output

### Tokens, Keywords, Identifiers
- [ ] Definitions and Examples
- [ ] Rules for Naming Identifiers
- [ ] Reserved Keywords in C++

### Data Types in C++
- [ ] Fundamental Data Types
- [ ] Derived Data Types
- [ ] User- [ ]Defined Data Types

### The `void` Data Type
- [ ] Purpose and Usage
- [ ] Limitations and Considerations

### Type Modifiers
- [ ] `const`, `volatile`, `mutable`
- [ ] `static`, `extern`

### Typecasting
- [ ] Implicit vs. Explicit Typecasting
- [ ] `static_cast`, `dynamic_cast`, `reinterpret_cast`, `const_cast`

### Constants
- [ ] Constants in C++
- [ ] `const` keyword
- [ ] `constexpr` keyword

### Operators
- [ ] Arithmetic Operators
- [ ] Relational Operators
- [ ] Logical Operators
- [ ] Assignment Operators
- [ ] Increment and Decrement Operators
- [ ] Bitwise Operators

### Precedence of Operators
- [ ] Operator Precedence and Associativity
- [ ] Order of Evaluation

### Strings
- [ ] Handling Strings in C++
- [ ] `std::string` class
- [ ] String Manipulation Functions

## Module 2: Control Structures and Functions

### Decision Making Statements
- [ ] `if- [ ]else` Statement
- [ ] Nested `if- [ ]else` Statement
- [ ] `switch- [ ]case` Statement
- [ ] `goto` Statement
- [ ] `break` and `continue` Statements

### Loop Statements
- [ ] `for` Loop
- [ ] Nested `for` Loop
- [ ] `while` Loop
- [ ] `do- [ ]while` Loop

### Parts of Function
- [ ] Function Prototype
- [ ] Function Definition
- [ ] Function Call

### User Defined Functions
- [ ] Defining Functions
- [ ] Calling Functions
- [ ] Passing Arguments

### Value- [ ]Returning Functions
- [ ] Functions with Return Values
- [ ] Returning Multiple Values

### Void Functions
- [ ] Functions without Return Values

### Value Parameters
- [ ] Passing Parameters by Value

### Function Overloading
- [ ] Definition and Purpose
- [ ] Rules for Overloading Functions
- [ ] Examples

### Virtual Functions
- [ ] Introduction to Polymorphism
- [ ] Virtual Functions and Function Overriding

## Module 3: Classes and Data Abstraction

### Structure in C++
- [ ] Declaring and Defining Structures
- [ ] Accessing Structure Members

### Class
- [ ] Declaration and Definition
- [ ] Public, Private, and Protected Members

### Built- [ ]in Operations on Classes
- [ ] Assignment Operator Overloading
- [ ] Copy Constructor
- [ ] Destructor

### Class Scope
- [ ] Scope Resolution Operator (::)
- [ ] Access Specifiers

### Reference Parameters and Class Objects
- [ ] Passing Objects by Reference
- [ ] Manipulating Class Objects via References

### Member Functions
- [ ] Definition and Declaration
- [ ] Inline Functions

### Accessor and Mutator Functions
- [ ] Getter and Setter Methods
- [ ] Encapsulation and Data Hiding

### Constructors
- [ ] Default Constructor
- [ ] Parameterized Constructor
- [ ] Copy Constructor

### Destructors
- [ ] Purpose and Usage
- [ ] Automatic vs. Manual Destruction

## Module 4: Overloading, Templates, and Inheritance

### Operator Overloading
- [ ] Overloading Unary and Binary Operators
- [ ] Examples and Use Cases

### Function Templates
- [ ] Generic Programming with Templates
- [ ] Template Functions vs. Function Overloading

### Class Templates
- [ ] Creating Generic Classes
- [ ] Template Class Specialization

### Single and Multiple Inheritance
- [ ] Defining Inheritance Relationships
- [ ] Inheriting Data and Methods

### Virtual Base Class
- [ ] Handling Diamond Problem
- [ ] Virtual Inheritance

### Abstract Class
- [ ] Pure Virtual Functions
- [ ] Abstract Classes vs. Concrete Classes

### Pointer and Inheritance
- [ ] Pointers to Base and Derived Classes
- [ ] Polymorphic Behavior

### Overloading Member Function
- [ ] Overloading Functions in Derived Classes
- [ ] Resolving Function Ambiguity

## Module 5: Pointers, Arrays and Exception Handling

### Void Pointers
- [ ] Purpose and Usage
- [ ] Type Safety Concerns

### Pointer to Class
- [ ] Pointers to Objects
- [ ] Accessing Members via Pointers

### Pointer to Object
- [ ] Storing Object Addresses
- [ ] Dynamic Memory Allocation

### Arrays
- [ ] Single- [ ]Dimensional Arrays
- [ ] Multi- [ ]Dimensional Arrays
- [ ] Array Manipulation

### Exception Handling
- [ ] Introduction to Exception Handling
- [ ] Syntax and Usage of `try`, `throw`, `catch`
- [ ] Exception Class Hierarchy

### Creating Own Exception Classes
- [ ] Custom Exception Classes
- [ ] Inheriting from Standard Exception Classes

### Exception Handling Techniques
- [ ] Terminate the Program
- [ ] Fix the Error and Continue
- [ ] Log the Error and Continue

### Stack Unwinding
- [ ] Process of Exception Propagation
- [ ] Resource Deallocation
